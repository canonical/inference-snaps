# Create an inference snap

In this tutorial we will create an inference snap for a large language model (LLM).
The focus is on learning the overall structure by packaging a single model and runtime, rather than making a snap that works on a wide range of machines.
Once we learn the basics, it is easy to extend it to include other model weights and runtimes. 

## Get started

Start by preparing the necessary files and tools.

### What you'll need

We use `snapcraft` to create snaps.
If you don't have it installed, refer to [this guide](https://documentation.ubuntu.com/snapcraft/stable/how-to/set-up-snapcraft/).

You will also need the model weights and a compatible runtime. 
But first, we need to pick an LLM. Gemma 3 is a good choice for this tutorial because it is open and available in small sizes.
Gemma 3 is free and permits responsible commercial use.
Read its full terms of use [here](https://ai.google.dev/gemma/terms).

Inference with a CPU is always a good starting point and a simple way to do that is via a {spellexception}`llama.cpp`-based runtime. 
The [{spellexception}`llama.cpp`](https://github.com/ggml-org/llama.cpp) project is backed by a large open source community working on various silicon optimizations. 
We can use the [{spellexception}`llama.cpp` HTTP server](https://github.com/ggml-org/llama.cpp/tree/master/tools/server) implementation which supports model weights in the GGUF format.

Google distributes GGUF formats for most of Gemma 3 model sizes. 
Go with a relatively small model to speed up development times and add larger ones later.
The [`gemma-3-1b-it-qat-q4_0-gguf`](https://huggingface.co/google/gemma-3-1b-it-qat-q4_0-gguf) is a good first instance.
Download the `gemma-3-1b-it-q4_0.gguf` file from the Hugging Face repository.

You may also use `tree` and `curl` which you can install with:
```shell
sudo apt update
sudo apt install tree curl
```

### The snapcraft.yaml

Start by creating the `snapcraft.yaml` file. Use the following command to create an initial project tree:
```shell
snapcraft init
```

Checkout the generated file:
```{terminal}
:input: tree .
.
└── snap
    └── snapcraft.yaml

2 directories, 1 file
```

Update the snapcraft file with sensible metadata.
Remove the parts that were generated by default.

Inference snaps are usually named after the model, e.g. `gemma3` for Gemma 3 model. 
Add your username to it as a suffix to create a unique snap name that can be uploaded to the store in order to complete this tutorial.

My snapcraft file looks like this:
```{literalinclude} create-inference-snap/snap/snapcraft.yaml
:caption: snap/snapcraft.yaml
:language: yaml
:start-after: start metadata
:end-before: end metadata
```


### The project tree

The project files can be organized in different ways.
There is no right or wrong way.
We organize the files in directory structure based on their purpose:
- `components` for the local snap component files
- `engines` for the engine manifests and related scripts
- `scripts` for various helper scripts
- `snap` for the snapcraft file and hooks

```{terminal}
:input: $ tree -d -L 1
.
├── components
├── engines
├── scripts
└── snap

5 directories
```

Use the kebab-case naming convention.
This isn't required but it makes the next steps easier as most parts of snaps support kebab-case naming only.

## Craft the snap

We need to extend the snapcraft file by adding:
- `parts`: the build logic
- `apps`: commands and services 
- `components`: optional building blocks
- `environments`: global environment variables
- `hooks`: settings for scripts that trigger on certain events

We also need to add a few supporting scripts.

### Global environment variables

It is useful to set some variables globally. Do this only for variables that are read from different parts of the snap's runtime environment.

Add the following to the snapcraft file for the common environment variables:
```{literalinclude} create-inference-snap/snap/snapcraft.yaml
:caption: snap/snapcraft.yaml
:language: yaml
:start-after: start environment
:end-before: end environment
```

### The CLI app

Inference snaps include a simple and powerful CLI. 
The CLI provides hardware detection, engine selection, component installation, server startup, config management, and other functionalities.

An open source implementation of the CLI is available [here](https://github.com/canonical/inference-snaps-cli). Let's add that to our snap.

Create a `parts` section in the snapcraft file:
```yaml
parts:
  ...
```

Add a *part* in the snapcraft file to build and include the CLI:
```{literalinclude} create-inference-snap/snap/snapcraft.yaml
:language: yaml
:start-after: start cli part
:end-before: end part
```
This will add `modelctl` command line tool to the snap package.
We will use it inside the snap for various tasks, such as engine selection and configuration.

Then, create an `apps` entry in the snapcraft file:
```yaml
apps:
  ...
```

Add the following *app*:
```{literalinclude} create-inference-snap/snap/snapcraft.yaml
:language: yaml
:start-after: start cli app
:end-before: end app
```
This app exposes the `modelctl` command line tool to the user, under the snap's name.

### Components

Runtime and model weights are considered optional building blocks of this snap. 
This does not make perfect sense right now because we only have one for each. 
But imagine this snap growing to have multiple of each, selected and downloaded on runtime based on the host machine.

We package optional building blocks in [snap components](https://snapcraft.io/docs/components). 
This enables us to build the snap with all the building blocks but install only what is relevant.

Create a `components` directory with two subdirectories: `model-1b-it-q4-0-gguf` for the model weights, and `llama-cpp` for the runtime.

Move the `.gguf` file downloaded earlier to the model directory. 

Add the following configuration files for the components. 

For the model:
```{literalinclude} create-inference-snap/components/model-1b-it-q4-0-gguf/component.yaml
:caption: {spellexception}`components/model-1b-it-q4-0-gguf/component.yaml`
:language: yaml
```

For the runtime:
```{literalinclude} create-inference-snap/components/llama-cpp/component.yaml
:caption: {spellexception}`components/llama-cpp/component.yaml`
:language: yaml
```

The variables set per component are passed on to the execution environment.

Finally, add a wrapper script for starting the server provided by this component:
```{literalinclude} create-inference-snap/components/llama-cpp/server
:caption: {spellexception}`components/llama-cpp/server`
:language: bash
```
Make the script executable: `chmod +x components/llama-cpp/server`

The above script loads the configurations and starts the HTTP server.

The {spellexception}`llama.cpp`'s HTTP server binary will be built from source during packaging and placed in the expected location. More on that later.

The `components` directory should now look like:
```{terminal}
:input: tree components/
components/
├── llama-cpp
│   ├── component.yaml
│   └── server
└── model-1b-it-q4-0-gguf
    └── component.yaml

3 directories, 3 files
```

We have created a couple of component directories, but the snap doesn't know anything about them yet.

Edit the snapcraft file.
Define one component for the runtime, and another one for the model weights:
```{literalinclude} create-inference-snap/snap/snapcraft.yaml
:language: yaml
:start-after: start components
:end-before: end components
```

Here, the component names must be kebab-case. 

If you build the snap now, it will create the `.snap` and two `.comp` files. 
The components will be empty.
We need to specify what gets packaged in them.

Add a new *part* to copy the local files from the `components` directory to the corresponding component within the package.

```{literalinclude} create-inference-snap/snap/snapcraft.yaml
:language: yaml
:start-after: start component-local-files part
:end-before: end part
```

`(component/<component name>)` is a special syntax to reference a defined component.

Furthermore, add a *part* to build {spellexception}`llama.cpp` from source and move the artifacts to the corresponding component:
```{literalinclude} create-inference-snap/snap/snapcraft.yaml
:language: yaml
:start-after: start llama-cpp part
:end-before: end part
```

We don't need all the {spellexception}`llama.cpp` artifacts, but that's okay for now. 
You can refine this *part* later to only include what is necessary.

The packaging logic for the components are now complete.
You can build the snap and verify the packages:
```{terminal}
:input: snapcraft pack
Packed: gemma3-jane_v3_amd64.snap, gemma3-jane+model-1b-it-q4-0-gguf.comp, gemma3-jane+llama-cpp.comp
```

### Engine

The runtime and model weights are tightly coupled components useful for certain host machines.
Each inference snaps can include a range of such components. 
In this tutorial we create a single {ref}`engine <engines>` that uses those components. 
Engines can reuse and customize components, for example to bundle a runtime with different model weights or to tweak the command line arguments.

Create an `engines` directory, with a subdirectory for our only engine named `generic-cpu`. 

Inside, create an `engine.yaml` file that defines the engine:
```{literalinclude} create-inference-snap/engines/generic-cpu/engine.yaml
:caption: engines/generic-cpu/engine.yaml
:language: yaml
```

`engine.yaml` is the {ref}`engine manifest file <engine-manifest>`. 
It describes the engine as well as its hardware and software requirements.
It can also set default configurations for the runtime.

Lastly, create a wrapper script that starts the runtime for this engine. 
In simplest cases, this simply runs a program provided by one of the components:
```{literalinclude} create-inference-snap/engines/generic-cpu/server
:caption: engines/generic-cpu/server
:language: bash
```
Make this script executable: `chmod +x engines/generic-cpu/server`

Add another *part* in snapcraft file to include the `engines` directory in the snap:
```{literalinclude} create-inference-snap/snap/snapcraft.yaml
:language: yaml
:start-after: start engines part
:end-before: end part
```

### The server app

Now, we need to expose the engine's server to the snap. 
We want the snap to run the server provided by the selected engine, as a background service.

In a top level `scripts` directory, add a wrapper script that abstracts away the engine selection and runs the server script of the selected engine:
```{literalinclude} create-inference-snap/scripts/server.sh
:caption: scripts/server.sh
:language: bash
``` 

Include the directory in the package, via a new *part*:
```{literalinclude} create-inference-snap/snap/snapcraft.yaml
:language: yaml
:start-after: start scripts part
:end-before: end part
```

Then, add a server *app* that runs `server.sh` as a background service:
```{literalinclude} create-inference-snap/snap/snapcraft.yaml
:language: yaml
:start-after: start server app
:end-before: end app
```
The above goes to the `apps` section of the snapcraft file.

### The install hook

Moreover, we need a script which takes care of the installation logic.
In snaps, the `install` hook is a script that runs when the snap is installed.

We want the installation event to trigger the detection of hardware capabilities of the host machine, and install the best matching components and engine.
```{literalinclude} create-inference-snap/snap/hooks/install
:caption: snap/hooks/install
:language: bash
```

This script gets added automatically to the snap if placed in the `snap/hooks` directory.
However, we need to grant it the necessary permissions to detect hardware.

Add the following to the snapcraft file to declare the required interface for the `install` hook:
```{literalinclude} create-inference-snap/snap/snapcraft.yaml
:language: yaml
:start-after: start hooks
:end-before: end hooks
```

### Licensing

Finally, add all license files to the snap. E.g. to add Gemma's license, add the following *part*:
```{literalinclude} create-inference-snap/snap/snapcraft.yaml
:language: yaml
:start-after: start gemma license part
:end-before: end part
```

## Build and deploy

With the crafting completed, it's time to build, test, and upload the snap.

### Test locally

```{terminal}
:input: snapcraft pack
Packed: gemma3-jane_v3_amd64.snap, gemma3-jane+model-1b-it-q4-0-gguf.comp, gemma3-jane+llama-cpp.comp

:input: sudo snap install --devmode gemma3-jane_v3_amd64.snap
gemma3-jane v3 installed
``` 

Checking `snap logs gemma3-jane` would show that the server has failed to start because no engine and components have been installed yet.
The reason for this is that the locally built snap cannot access the component files and install them automatically.

We have to install the components and select the engine manually now, but the `install` hook will take care of this automatically when the same snap is installed from the store.

```{terminal}
:input: sudo snap install --dangerous gemma3-jane+model-1b-it-q4-0-gguf.comp
component model-1b-it-q4-0-gguf v3 for gemma3-jane v3 installed

:input: sudo snap install --dangerous gemma3-jane+llama-cpp.comp 
component llama-cpp v3 for gemma3-jane v3 installed

:input: sudo gemma3-jane use-engine generic-cpu
Engine successfully changed to "generic-cpu"

:input: sudo snap start gemma3-jane
Started.
```

````{tip}
Chain the commands together to install all artifacts in one go when going through multiple development and build cycles:
```shell
sudo snap install --dangerous gemma3-jane_v3_amd64.snap && \ 
sudo snap install --dangerous gemma3-jane+model-1b-it-q4-0-gguf.comp && \
sudo snap install --dangerous gemma3-jane+llama-cpp.comp 
```

You can also use wildcards if you don't have any other snap artifacts in that directory:
```shell
sudo snap install --dangerous *.snap && \
sudo snap install --dangerous *.comp
```
````

After starting the server, check the logs again and make sure it started successfully:
```{terminal}
:input: snap logs gemma3-jane
...
2025-11-13T15:34:52+01:00 gemma3-jane.server[241059]: main: server is listening on http://127.0.0.1:9090 - starting the main loop
2025-11-13T15:34:52+01:00 gemma3-jane.server[241059]: srv  update_slots: all slots are idle
```

Looks like the server is up and running!

Submit a request via curl:
```{terminal}
:input: curl -s http://localhost:9090/v1/chat/completions   -H "Content-Type: application/json"   -d '{
    "max_tokens": 30,
    "temperature": 0,
    "stream": false,
    "messages": [
      { "role": "system", "content": "You are a helpful assistant." },
      { "role": "user", "content": "What are the 3 main tourist attractions in Paris?" }
    ]                                                                                   
  }'
{"choices":[{"finish_reason":"length","index":0,"message":{"role":"assistant","content":"Okay, here are the 3 main tourist attractions in Paris:\n\n1.  **The Eiffel Tower:** Undoubtedly the most iconic landmark in the world"}}],"created":1763044754,"model":"gpt-3.5-turbo","system_fingerprint":"b1-6a746cf","object":"chat.completion","usage":{"completion_tokens":30,"prompt_tokens":28,"total_tokens":58},"id":"chatcmpl-PLT9wXbZiJ6XXxHCQUBsTz9wj59y2KHU","timings":{"prompt_n":28,"prompt_ms":90.995,"prompt_per_token_ms":3.249821428571429,"prompt_per_second":307.7092147920215,"predicted_n":30,"predicted_ms":833.198,"predicted_per_token_ms":27.773266666666665,"predicted_per_second":36.005847349609574}}
```

That worked! We have created an inference snap for Gemma 3 model, with just one engine.


### Upload

Uploading the snap to the store unlocks the automatic engine selection and component installation functionality.
Moreover, it lets others easily install and use the snap.

Uploading requires a few steps. Here is the list:
1. Register the name
2. Get yourself added to component upload allow-list
3. Upload the snap
4. Request interface connection permission for the hardware-observe interface

First you need to register the snap name in the store.
Refer to [this guide](https://snapcraft.io/docs/registering-your-app-name) to do that.

Uploading snaps with components currently requires a special permission. This is needed per account.
Request to be added to the component upload allow-list by posting in the [Snapcraft forum](https://forum.snapcraft.io/c/store-requests/19).
There is no subcategory for component uploads, so just post without picking one.

Once you have the permission, upload the snap and its components:
```shell
snapcraft upload gemma3-jane_v3_amd64.snap \
  --component model-1b-it-q4-0-gguf=gemma3-jane+model-1b-it-q4-0-gguf.comp \
  --component llama-cpp=gemma3-jane+llama-cpp.comp \
  --release edge
```

At this point, the snap is in the store but it cannot access hardware information during the installation.
We can work around this by installing it in developer mode:
```shell
sudo snap install --devmode gemma3-jane --edge
```

The developer mode allows the snap to access many other system resources as well, which is not ideal.
Moreover, snaps installed in developer mode cannot be updated automatically from the store.

If we install the snap in normal (confined) mode at this point, it will install but skip hardware detection and engine selection.
We can still grant permission and resume manually:
```shell
sudo snap install gemma3-jane --edge
sudo snap connect gemma3-jane:hardware-observe
sudo gemma3-jane use-engine --auto
```

But we can do better than this.
The snap store can grant the snap permission to auto connect the hardware-observe plug.
Submit a request on the [Snapcraft forum](https://forum.snapcraft.io/c/store-requests/privileged-interfaces/27) to get this permission for your snap.
An example, extended request can be found [here](https://forum.snapcraft.io/t/auto-connection-of-hardware-observe-and-home-for-gemma3/49246).

Once the permission is granted, you can install the snap and it will be ready to use right away.

### Install and use

Install the snap from the store:
```{terminal}
:input: sudo snap install gemma3-jane --edge
gemma3-jane v3 installed

:input: gemma3-jane status
engine: generic-cpu
endpoints:
    openai: http://localhost:9090/v1
```

## Next steps

We created a basic inference snap for Gemma 3 model with a single engine. 
You can extend it in various ways, for example to add an additional engine for GPU support.

The snap that you built will only work on the same OS architecture as the one you built it on.
You can build it for an architecture different from your host machine. 
One way to do this is via the [remote build](https://documentation.ubuntu.com/snapcraft/stable/explanation/remote-build/) feature of snapcraft.

You may also have noticed the CLI doesn't offer tab completion.
You can find some guidance for adding it temporarily, e.g. for Bash `gemma3-jane completion bash -h`.
The tab completion can also be added to the snap itself.

Look into {ref}`existing inference snaps <available-snaps>` to learn more about these and other advanced topics.
